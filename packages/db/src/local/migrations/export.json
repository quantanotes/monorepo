[
  {
    "sql": [
      "create table pks_cache (\r\n  tbl_name text not null primary key,\r\n  pks text [] not null\r\n);\r\n\r\n",
      "\r\n\r\ncreate or replace function get_pks(tbl_name text)\r\nreturns text[] as $$\r\ndeclare\r\n\tpks text[];\r\nbegin\r\n\tselect array_agg(c.column_name)\r\n\tinto pks\r\n\tfrom information_schema.table_constraints tc \r\n\tjoin information_schema.constraint_column_usage\r\n\t\tas ccu\r\n\t\tusing (constraint_schema, constraint_name) \r\n\tjoin information_schema.columns\r\n\t\tas c ON c.table_schema = tc.constraint_schema\r\n  \t\tand tc.table_name = c.table_name\r\n\t\tand ccu.column_name = c.column_name\r\n\twhere constraint_type = 'PRIMARY KEY' and tc.table_name = tbl_name;\r\n\r\n\treturn pks;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function cache_pks(tbl_name text)\r\nreturns void as $$\r\ndeclare\r\n\tpks text[];\r\nbegin\r\n\tselect *\r\n\tinto pks\r\n\tfrom get_pks(tbl_name);\r\n\t\r\n\tinsert into pks_cache(tbl_name, pks)\r\n\tvalues (tbl_name, pks);\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function get_pks_cached(tbl_name_in text)\r\nreturns text[] as $$\r\ndeclare\r\n\tpks_out text[];\r\nbegin\r\n\tselect pks into pks_out\r\n\tfrom pks_cache\r\n\twhere tbl_name = tbl_name_in;\r\n\r\n\treturn pks_out;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function get_where_clause(tbl_name text, record anyelement)\r\nreturns text as $$\r\ndeclare\r\n\ttbl_name text;\r\n\tpk text;\r\n\tpks text[];\r\n\twhere_conds text[];\r\n\tpk_val text;\r\nbegin\r\n  tbl_name := pg_typeof(record)::text;\r\n  pks := get_pks_cached(tbl_name);\r\n  where_conds := array[]::text[];\r\n    \r\n\tforeach pk in array pks\r\n\tloop\r\n\t\texecute format('select ($1).%I', pk) into pk_val using record;\r\n\t\twhere_conds := array_append(\r\n\t\t\twhere_conds,\r\n\t\t\tformat('%I = %L', pk, pk_val)\r\n\t\t);\r\n\tend loop;\r\n    \r\n  return array_to_string(where_conds, ' AND ');\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function get_data_cols(tbl_name text)\r\nreturns text[] as $$\r\ndeclare\r\n  pks text[];\r\n  sync_cols text[] := array[\r\n    'is_new',\r\n    'is_deleted',\r\n    'is_sent',\r\n    'is_synced',\r\n    'modified_columns',\r\n    'backup'\r\n  ];\r\n  cols text[];\r\nbegin\r\n  pks := get_pks_cached(tbl_name);\r\n\r\n  select array_agg(c.column_name)\r\n  into cols \r\n  from information_schema.columns c\r\n  where c.table_name = tbl_name\r\n  \tand c.table_schema = current_schema()\r\n    and c.column_name != ALL(pks)\r\n    and c.column_name != ALL(sync_cols);\r\n\r\n  return cols;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function is_syncing()\r\nreturns boolean AS $$\r\nbegin\r\n  return coalesce(nullif(current_setting('electric.syncing', true), ''), 'false')::boolean;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function should_bypass_triggers()\r\nreturns boolean AS $$\r\nbegin\r\n  return coalesce(nullif(current_setting('electric.bypass_triggers', true), ''), 'false')::boolean;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function handle_insert()\r\nreturns trigger as $$\r\ndeclare\r\n\tcol TEXT;\r\n  new_value TEXT;\r\n  old_value TEXT;\r\n\twhere_clause TEXT;\r\nbegin\r\n\tif should_bypass_triggers() then\r\n\t\treturn new;\r\n\tend if;\r\n\r\n\twhere_clause := get_where_clause(tg_table_name, new);\r\n\r\n\tif is_syncing() then\r\n\t\tnew.is_new := false;\r\n\t\tnew.is_sent := false;\r\n\t\tnew.modified_columns := array[]::text[];\r\n\r\n\t\texecute format('select 1 from %I where %s', tg_table_name, where_clause) into old_value;\r\n\r\n\t\tif old_value is not null then\r\n\t\t\tforeach col in array get_data_cols(tg_table_name)\r\n\t\t\tloop\r\n\t\t\t\texecute format('select $1.%I', col) using new into new_value;\r\n\t\t\t\texecute format('select %I from %I where %s', col, tg_table_name, where_clause) into old_value;\r\n\r\n\t\t\t\tif new_value is distinct from old_value then\r\n\t\t\t\t\texecute format('update %I set %I = $1 where %s', tg_table_name, col, where_clause) using new_value;\r\n\t\t\t\tend if;\r\n\t\t\tend loop;\r\n\r\n\t\t\texecute format(\r\n\t\t\t\t'update %I set modified_columns = $1, is_new = $2, is_sent = $3 where %s',\r\n\t\t\t\ttg_table_name,\r\n\t\t\t\twhere_clause\r\n\t\t\t) using array[]::text[], false, false;\r\n\r\n\t\t\treturn null;\r\n\t\tend if;\r\n\telse\r\n\t\tnew.modified_columns := get_data_cols(tg_table_name);\r\n\t\tnew.is_new := true;\r\n\tend if;\r\n\r\n\treturn new;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function handle_update()\r\nreturns trigger as $$\r\ndeclare\r\n\tcol TEXT;\r\n  new_value TEXT;\r\n  old_value TEXT;\r\n\twhere_clause TEXT;\r\nbegin\r\n\tif should_bypass_triggers() then\r\n\t\treturn new;\r\n\tend if;\r\n\r\n\twhere_clause := get_where_clause(tg_table_name, new);\r\n\r\n\tif is_syncing() then\r\n\t\tif (old.is_synced = true) or (old.is_sent = true and new.updated_at >= old.updated_at) then\r\n\t\t\tnew.is_new := false;\r\n\t\t\tnew.is_sent := false;\r\n\t\t\tnew.modified_columns := array[]::text[];\r\n\t\t\tnew.backup := null;\r\n\t\telse\r\n\t\t\tforeach col in array get_data_cols(tg_table_name)\r\n\t\t\tloop\r\n        if col != any(old.modified_columns) then\r\n          execute format('select ($1).%I', col) using new into new_value;\r\n          execute format('select ($1).%I', col) using old into old_value;\r\n\t\t\t\t\t     \r\n          if new_value is distinct from old_value then\r\n            execute format(\r\n\t\t\t\t\t\t\t'update %I set %I = $1 where %s',\r\n\t\t\t\t\t\t\ttg_table_name,\r\n\t\t\t\t\t\t\tcol,\r\n\t\t\t\t\t\t\twhere_clause\r\n\t\t\t\t\t\t) using new_value;\r\n\r\n            new.backup := jsonb_set(\r\n\t\t\t\t\t\t\tcoalesce(new.backup, '{}'::jsonb),\r\n\t\t\t\t\t\t\tarray[col],\r\n\t\t\t\t\t\t\tto_jsonb(old_value)\r\n\t\t\t\t\t\t);\r\n          end if;\r\n        end if;\r\n\t\t\tend loop;\r\n\t\tend if;\r\n\telse\r\n\t\tforeach col in array get_data_cols(tg_table_name)\r\n\t\tloop\r\n\t\t\texecute format('select ($1).%I', col) using new into new_value;\r\n\t\t\texecute format('select ($1).%I', col) using old into old_value;\r\n\r\n\t\t\tif new_value is distinct from old_value then\r\n\t\t\t\tif not (col = any(old.modified_columns)) then\r\n\t\t\t\t\tnew.modified_columns := array_append(\r\n\t\t\t\t\t\tnew.modified_columns,\r\n\t\t\t\t\t\tcol\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tnew.backup := jsonb_set(\r\n\t\t\t\t\t\tcoalesce(new.backup, '{}'::jsonb),\r\n\t\t\t\t\t\tarray[col],\r\n\t\t\t\t\t\tto_jsonb(old_value)\r\n\t\t\t\t\t);\r\n\t\t\t\tend if;\r\n\t\t\tend if;\r\n\t\tend loop;\r\n\r\n\t\tnew.is_sent := false;\r\n\tend if;\r\n\t\r\n\treturn new;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace function handle_delete()\r\nreturns trigger as $$\r\nbegin\r\n\tif should_bypass_triggers() then\r\n\t\treturn old;\r\n\tend if;\r\n\r\n\tif is_syncing() then\r\n\t\treturn old;\r\n\telse\r\n\t\tif old.is_new then\r\n\t\t\treturn old;\r\n\t\telse\r\n\t\t\texecute format(\r\n\t\t\t\t'update %I set is_deleted = true where %s',\r\n\t\t\t\ttg_table_name,\r\n\t\t\t\tget_where_clause(tg_table_name, old)\r\n\t\t\t);\r\n\t\t\treturn null;\r\n\t\tend if;\r\n\tend if;\r\nend;\r\n$$ language plpgsql;\r\n\r\n",
      "\r\n\r\ncreate or replace procedure activate_triggers(tbl_name text)\r\nlanguage plpgsql as $$\r\nbegin\r\n\texecute format('\r\n\t\tselect cache_pks(%1$L);\r\n\r\n    create or replace trigger %1$I_insert_trigger\r\n    before insert on %1$I\r\n\t\tfor each row\r\n\t\twhen (pg_trigger_depth() = 0)\r\n    execute function handle_insert(); \r\n\r\n    create or replace trigger %1$I_update_trigger\r\n    before update on %1$I\r\n\t\tfor each row\r\n\t\twhen (pg_trigger_depth() = 0)\r\n    execute function handle_update(); \r\n\r\n    create or replace trigger %1$I_delete_trigger\r\n    before delete on %1$I\r\n\t\tfor each row\r\n\t\twhen (pg_trigger_depth() = 0)\r\n    execute function handle_delete(); \r\n\t', tbl_name);\r\nend;\r\n$$;\r\n"
    ],
    "bps": true,
    "folderMillis": 1737367971921,
    "hash": "9d4898130c15327d6f3f70d6b625bb6108c059084f3d70a4416b2cbdf2b88e94"
  },
  {
    "sql": [
      "CREATE TYPE \"public\".\"tag_types\" AS ENUM('text', 'number', 'boolean', 'reference', 'date', 'datetime', 'duration', 'url');",
      "\nCREATE TABLE \"object_tags\" (\n\t\"space_id\" varchar(12) NOT NULL,\n\t\"object_id\" varchar(12) NOT NULL,\n\t\"tag_id\" varchar(12) NOT NULL,\n\t\"value\" jsonb,\n\t\"type\" \"tag_types\",\n\t\"created_at\" timestamp DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp DEFAULT now() NOT NULL,\n\t\"is_new\" boolean DEFAULT false NOT NULL,\n\t\"is_deleted\" boolean DEFAULT false NOT NULL,\n\t\"is_sent\" boolean DEFAULT false NOT NULL,\n\t\"is_synced\" boolean GENERATED ALWAYS AS (ARRAY_LENGTH(modified_columns, 1) IS NULL AND NOT is_deleted AND NOT is_new) STORED,\n\t\"modified_columns\" text[] DEFAULT '{}',\n\t\"backup\" jsonb,\n\tCONSTRAINT \"object_tags_object_id_tag_id_pk\" PRIMARY KEY(\"object_id\",\"tag_id\")\n);\n",
      "\nCREATE TABLE \"objects\" (\n\t\"id\" varchar(12) PRIMARY KEY NOT NULL,\n\t\"space_id\" varchar(12) NOT NULL,\n\t\"parent_id\" varchar(12),\n\t\"name\" text NOT NULL,\n\t\"content\" text NOT NULL,\n\t\"view\" varchar NOT NULL,\n\t\"order\" integer DEFAULT 0 NOT NULL,\n\t\"embedding\" vector(1536),\n\t\"is_embedded\" boolean DEFAULT false NOT NULL,\n\t\"created_at\" timestamp DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp DEFAULT now() NOT NULL,\n\t\"is_new\" boolean DEFAULT false NOT NULL,\n\t\"is_deleted\" boolean DEFAULT false NOT NULL,\n\t\"is_sent\" boolean DEFAULT false NOT NULL,\n\t\"is_synced\" boolean GENERATED ALWAYS AS (ARRAY_LENGTH(modified_columns, 1) IS NULL AND NOT is_deleted AND NOT is_new) STORED,\n\t\"modified_columns\" text[] DEFAULT '{}',\n\t\"backup\" jsonb\n);\n",
      "\nCREATE TABLE \"pinned\" (\n\t\"id\" varchar(12) PRIMARY KEY NOT NULL,\n\t\"space_id\" varchar(12) NOT NULL,\n\t\"object_id\" varchar(12),\n\t\"tag_id\" varchar(12),\n\t\"type\" varchar NOT NULL,\n\t\"order\" integer DEFAULT 0 NOT NULL,\n\t\"created_at\" timestamp DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp DEFAULT now() NOT NULL,\n\t\"is_new\" boolean DEFAULT false NOT NULL,\n\t\"is_deleted\" boolean DEFAULT false NOT NULL,\n\t\"is_sent\" boolean DEFAULT false NOT NULL,\n\t\"is_synced\" boolean GENERATED ALWAYS AS (ARRAY_LENGTH(modified_columns, 1) IS NULL AND NOT is_deleted AND NOT is_new) STORED,\n\t\"modified_columns\" text[] DEFAULT '{}',\n\t\"backup\" jsonb,\n\tCONSTRAINT \"pinned_objectId_unique\" UNIQUE(\"object_id\")\n);\n",
      "\nCREATE TABLE \"tag_tags\" (\n\t\"space_id\" varchar(12) NOT NULL,\n\t\"tag_id\" varchar(12) NOT NULL,\n\t\"parent_id\" varchar(12) NOT NULL,\n\t\"order\" integer DEFAULT 0 NOT NULL,\n\t\"created_at\" timestamp DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp DEFAULT now() NOT NULL,\n\t\"is_new\" boolean DEFAULT false NOT NULL,\n\t\"is_deleted\" boolean DEFAULT false NOT NULL,\n\t\"is_sent\" boolean DEFAULT false NOT NULL,\n\t\"is_synced\" boolean GENERATED ALWAYS AS (ARRAY_LENGTH(modified_columns, 1) IS NULL AND NOT is_deleted AND NOT is_new) STORED,\n\t\"modified_columns\" text[] DEFAULT '{}',\n\t\"backup\" jsonb,\n\tCONSTRAINT \"tag_tags_tag_id_parent_id_pk\" PRIMARY KEY(\"tag_id\",\"parent_id\")\n);\n",
      "\nCREATE TABLE \"tags\" (\n\t\"id\" varchar(12) PRIMARY KEY NOT NULL,\n\t\"space_id\" varchar(12) NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"order\" integer DEFAULT 0 NOT NULL,\n\t\"color\" text,\n\t\"type\" \"tag_types\",\n\t\"default\" jsonb,\n\t\"created_at\" timestamp DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp DEFAULT now() NOT NULL,\n\t\"is_new\" boolean DEFAULT false NOT NULL,\n\t\"is_deleted\" boolean DEFAULT false NOT NULL,\n\t\"is_sent\" boolean DEFAULT false NOT NULL,\n\t\"is_synced\" boolean GENERATED ALWAYS AS (ARRAY_LENGTH(modified_columns, 1) IS NULL AND NOT is_deleted AND NOT is_new) STORED,\n\t\"modified_columns\" text[] DEFAULT '{}',\n\t\"backup\" jsonb,\n\tCONSTRAINT \"tags_spaceId_name_unique\" UNIQUE(\"space_id\",\"name\")\n);\n",
      "\nCREATE TABLE \"tasks\" (\n\t\"id\" varchar(12) PRIMARY KEY NOT NULL,\n\t\"space_id\" varchar(12) NOT NULL,\n\t\"name\" text NOT NULL,\n\t\"description\" text NOT NULL,\n\t\"code\" text NOT NULL,\n\t\"created_at\" timestamp DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp DEFAULT now() NOT NULL,\n\t\"is_new\" boolean DEFAULT false NOT NULL,\n\t\"is_deleted\" boolean DEFAULT false NOT NULL,\n\t\"is_sent\" boolean DEFAULT false NOT NULL,\n\t\"is_synced\" boolean GENERATED ALWAYS AS (ARRAY_LENGTH(modified_columns, 1) IS NULL AND NOT is_deleted AND NOT is_new) STORED,\n\t\"modified_columns\" text[] DEFAULT '{}',\n\t\"backup\" jsonb\n);\n",
      "\nCREATE TABLE \"tools\" (\n\t\"id\" varchar(12) PRIMARY KEY NOT NULL,\n\t\"space_id\" varchar(12) NOT NULL,\n\t\"name\" text DEFAULT '' NOT NULL,\n\t\"type\" text NOT NULL,\n\t\"config\" jsonb,\n\t\"created_at\" timestamp DEFAULT now() NOT NULL,\n\t\"updated_at\" timestamp DEFAULT now() NOT NULL,\n\t\"is_new\" boolean DEFAULT false NOT NULL,\n\t\"is_deleted\" boolean DEFAULT false NOT NULL,\n\t\"is_sent\" boolean DEFAULT false NOT NULL,\n\t\"is_synced\" boolean GENERATED ALWAYS AS (ARRAY_LENGTH(modified_columns, 1) IS NULL AND NOT is_deleted AND NOT is_new) STORED,\n\t\"modified_columns\" text[] DEFAULT '{}',\n\t\"backup\" jsonb\n);\n",
      "\n-- ALTER TABLE \"object_tags\" ADD CONSTRAINT \"object_tags_object_id_objects_id_fk\" FOREIGN KEY (\"object_id\") REFERENCES \"public\".\"objects\"(\"id\") ON DELETE cascade ON UPDATE no action;",
      "\n-- ALTER TABLE \"object_tags\" ADD CONSTRAINT \"object_tags_tag_id_tags_id_fk\" FOREIGN KEY (\"tag_id\") REFERENCES \"public\".\"tags\"(\"id\") ON DELETE cascade ON UPDATE no action;",
      "\n-- ALTER TABLE \"pinned\" ADD CONSTRAINT \"pinned_object_id_objects_id_fk\" FOREIGN KEY (\"object_id\") REFERENCES \"public\".\"objects\"(\"id\") ON DELETE cascade ON UPDATE no action;",
      "\n-- ALTER TABLE \"pinned\" ADD CONSTRAINT \"pinned_tag_id_tags_id_fk\" FOREIGN KEY (\"tag_id\") REFERENCES \"public\".\"tags\"(\"id\") ON DELETE cascade ON UPDATE no action;",
      "\n-- ALTER TABLE \"tag_tags\" ADD CONSTRAINT \"tag_tags_tag_id_tags_id_fk\" FOREIGN KEY (\"tag_id\") REFERENCES \"public\".\"tags\"(\"id\") ON DELETE cascade ON UPDATE no action;",
      "\n-- ALTER TABLE \"tag_tags\" ADD CONSTRAINT \"tag_tags_parent_id_tags_id_fk\" FOREIGN KEY (\"parent_id\") REFERENCES \"public\".\"tags\"(\"id\") ON DELETE cascade ON UPDATE no action;",
      "\nCREATE INDEX \"object_tags_is_new_index\" ON \"object_tags\" USING btree (\"is_new\");",
      "\nCREATE INDEX \"object_tags_is_deleted_index\" ON \"object_tags\" USING btree (\"is_deleted\");",
      "\nCREATE INDEX \"object_tags_is_synced_index\" ON \"object_tags\" USING btree (\"is_synced\");",
      "\nCREATE INDEX \"objects_is_new_index\" ON \"objects\" USING btree (\"is_new\");",
      "\nCREATE INDEX \"objects_is_deleted_index\" ON \"objects\" USING btree (\"is_deleted\");",
      "\nCREATE INDEX \"objects_is_synced_index\" ON \"objects\" USING btree (\"is_synced\");",
      "\nCREATE INDEX \"pinned_is_new_index\" ON \"pinned\" USING btree (\"is_new\");",
      "\nCREATE INDEX \"pinned_is_deleted_index\" ON \"pinned\" USING btree (\"is_deleted\");",
      "\nCREATE INDEX \"pinned_is_synced_index\" ON \"pinned\" USING btree (\"is_synced\");",
      "\nCREATE INDEX \"tag_tags_is_new_index\" ON \"tag_tags\" USING btree (\"is_new\");",
      "\nCREATE INDEX \"tag_tags_is_deleted_index\" ON \"tag_tags\" USING btree (\"is_deleted\");",
      "\nCREATE INDEX \"tag_tags_is_synced_index\" ON \"tag_tags\" USING btree (\"is_synced\");",
      "\nCREATE INDEX \"tags_is_new_index\" ON \"tags\" USING btree (\"is_new\");",
      "\nCREATE INDEX \"tags_is_deleted_index\" ON \"tags\" USING btree (\"is_deleted\");",
      "\nCREATE INDEX \"tags_is_synced_index\" ON \"tags\" USING btree (\"is_synced\");",
      "\nCREATE INDEX \"tasks_is_new_index\" ON \"tasks\" USING btree (\"is_new\");",
      "\nCREATE INDEX \"tasks_is_deleted_index\" ON \"tasks\" USING btree (\"is_deleted\");",
      "\nCREATE INDEX \"tasks_is_synced_index\" ON \"tasks\" USING btree (\"is_synced\");",
      "\nCREATE INDEX \"tools_is_new_index\" ON \"tools\" USING btree (\"is_new\");",
      "\nCREATE INDEX \"tools_is_deleted_index\" ON \"tools\" USING btree (\"is_deleted\");",
      "\nCREATE INDEX \"tools_is_synced_index\" ON \"tools\" USING btree (\"is_synced\");"
    ],
    "bps": true,
    "folderMillis": 1739184515338,
    "hash": "b73b3e55785f2df540fc687acb8aa19616293aa89db2380242184a48c810e61a"
  },
  {
    "sql": [
      "create table sync_status (\r\n  table_name text not null,\r\n  space_id text not null,\r\n  is_synced boolean not null default false,\r\n  primary key (table_name, is_synced)\r\n);\r\n",
      "\r\ncall activate_triggers('objects'); ",
      "\r\ncall activate_triggers('tags'); ",
      "\r\ncall activate_triggers('object_tags'); ",
      "\r\ncall activate_triggers('tools'); ",
      "\r\ncall activate_triggers('tasks'); ",
      "\r\ncall activate_triggers('pinned'); ",
      ""
    ],
    "bps": true,
    "folderMillis": 1739184530384,
    "hash": "b19c430f40b47b95ca8abc50baf37383de9ef80601c913d6188fdbc02ea4f84d"
  }
]